#
# Executes commands at the start of an interactive session.
#
# Authors:
#   Naokazu Terada <naokazu.terada@gmail.com>
#

# Source Prezto.
if [[ -s "${ZDOTDIR:-$HOME}/.zprezto/init.zsh" ]]; then
  source "${ZDOTDIR:-$HOME}/.zprezto/init.zsh"
fi

# ====================
# PATH settings (before anyenv to ensure proper priority)
# ====================
# Homebrew
export PATH=/opt/homebrew/bin:$PATH
export PATH="/opt/homebrew/opt/llvm/bin:$PATH"
# MAMP
export PATH=/Applications/MAMP/bin/php/php8.3.0/bin:$PATH
export PATH=$PATH:/Applications/MAMP/Library/bin/
# User binaries
export PATH=$PATH:$HOME/bin
export PATH=$PATH:$HOME/.rbenv/bin
export PATH=$PATH:$HOME/.dotfiles/functions
# AWS CLI
export PATH=~/.local/bin:$PATH
# Project local
export PATH=$PATH:./vendor/bin:./bin  # bundler
export PATH=$PATH:./node_modules/.bin  # npm

# anyenv initialization (after PATH settings so nodenv shims take priority)
export PATH="$HOME/.anyenv/bin:$PATH"
eval "$(anyenv init -)"

# Customize to your needs...

autoload -Uz zmv

# Partially disable the zsh's autocorrect feature
# 下記コマンドについて、Zshのcorrect機能を表示させないようにする
cmmnds=(cf dg eslint gulp ncu nuxt rspec rubocop vercel)
for cmmnd in "${cmmnds[@]}"; do
  alias $cmmnd="nocorrect $cmmnd"
done

# cd XXX
alias d='cd ~/Desktop'
alias s='cd ~/Sites'
alias dotfiles='cd ~/.dotfiles'
alias dotfile='dotfiles'
alias dot='dotfiles'
alias ops='cd ~/Documents/ops'
alias wp-themes='cd ./wp/wp-content/themes'

# open XXX
alias od='open ~/Desktop'
alias odot='open ~/Sites'
alias os='open ~/Sites'
alias kindle2pdf='cd ~/Applications/kindle2pdf && open .'

alias htpasswd='$HOME/.dotfiles/functions/htpasswd'

# Local IP address
# WiFiとEthernetでIPが違うので、どちらでも大丈夫なようリストから選択式
alias ip='networksetup -listallhardwareports | peco | perl -pe "s/Device: (en[0-9]+)/\1/g;" | xargs ipconfig getifaddr'

alias o='source ~/.dotfiles/functions/open_with_sublime_sourcetree.sh'
alias a='source ~/.dotfiles/functions/open_with_atom_sourcetree.sh'
alias mkcd='source ~/.dotfiles/functions/mkdir_cd.sh'

alias m='middleman'
alias m_new='middleman_new'

# NPM
# Updating packages with 'node-check-updates'
alias ncu='npx npm-check -u'
# Pecoを使ってnpm scriptsをリスト化
alias npmrun='npm run $(commands | peco)'
function commands () {
  cat package.json | jq -r '.scripts | keys[]'
}

alias f='foreman'
alias g='git'
alias gitignore='gibo'
alias st='open -a SourceTree'
alias v='vagrant'

# rbenvを使った環境用
function re   { rbenv exec "$@"; }
function reb  { rbenv exec bundle "$@"; }
function rebe { rbenv exec bundle exec "$@"; }

alias rebi='reb install --path=vendor/bundle --binstubs=vendor/bin'
alias rebem='rebe middleman'
alias rebef='rebe foreman start --procfile=ProcfileDev'

export RUBY_CFLAGS="-Wno-error=implicit-function-declaration"

# Determining my public IP
# Ref: https://www.cyberciti.biz/faq/how-to-find-my-public-ip-address-from-command-line-on-a-linux/
alias myip='dig +short myip.opendns.com @resolver1.opendns.com'

# Clear DNS cache
alias clearDNS='sudo killall -HUP mDNSResponder'

# Chrome log
# https://support.google.com/chrome/a/answer/6271282?hl=en
alias chrome_log='/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --enable-logging=stderr --v=1'

# pecoを使ってプロセス名から選んでシグナルを送る
alias intps='ps -ax | peco | xargs kill -2' # 割り込み（Ctrl+Cと同じ）
alias quitps='ps -ax | peco | xargs kill -3' # 終了
alias killps='ps -ax | peco | xargs kill -9' # 強制終了
alias termps='ps -ax | peco | xargs kill -15' # 終了
# 使用しているportで探してkill
killpt() { lsof -i tcp:$1 | awk 'NR!=1 {print $2}' | xargs kill ; }
killport() { killpt $1; }

# SSHの公開鍵を素早くコピー、サーバーへログインしてauthorized_keysにペースト
alias copy-rsa='cat ~/.ssh/id_rsa.pub | pbcopy'

# サブディレクトリを含めてファイルサイズ順に並べる
# Ref: https://unix.stackexchange.com/questions/88065/sorting-files-according-to-size-recursively
# ※ 出力が大きくなるのでheadやtailを使うこと
# ファイルのみ
# Usage:
# list-file-size | head -5
alias list-file-size='find . -type f -exec du -ah {} + | grep -v "/$" | sort -rh'
# ディレクトリも含めたい場合
# Usage:
# list-file-dir-size | head -5
alias list-file-dir-size='du -ah . | grep -v "/$" | sort -rh'

# middleman-templateをclone
alias middleman_template='git clone --recursive https://github.com/naokazuterada/middleman-template.git'

# Excelが重くなった際にキャッシュを削除する
# 参考: https://getpocket.com/a/read/1262698222
alias excel_cleanup='rm -rf ~/Library/Preferences/com.microsoft.Excel.plist ~/Library/Preferences/com.microsoft.office.plist ~/Library/Caches/Microsoft ~/Library/Caches/Microsoft\ Office'

# HEICファイルをjpgに変換
# - ファイルを指定した場合: そのファイルをJPGに変換
# - ディレクトリを指定した場合: 配下の全HEIC/heicファイルを再帰的にJPGに変換
# - 変換後、元のHEICファイルを削除するか確認
# Usage:
#   heic2jpg /path/to/file.HEIC
#   heic2jpg /path/to/directory
function heic2jpg {
  # 引数チェック
  if [[ -z "$1" ]]; then
    echo "Usage: heic2jpg /path/to/file.HEIC または heic2jpg /path/to/directory"
    return 1
  fi

  if [[ ! -e "$1" ]]; then
    echo "エラー: $1 が見つかりません"
    return 1
  fi

  local converted_files=()

  # 単一ファイルの変換処理
  local _convert() {
    if sips --setProperty format jpeg "$1" --out "${1:r}.jpg" 2>/dev/null; then
      converted_files+=("$1")
    fi
  }

  if [[ -d "$1" ]]; then
    # ディレクトリの場合: サブディレクトリ含め全てのHEICファイルを変換
    # (N): 該当ファイルがなくてもエラーを出さない (null glob)
    for f in "$1"/**/*.(heic|HEIC)(N); do
      _convert "$f"
    done
  else
    # ファイルの場合: HEICファイルかチェック
    if [[ "$1" =~ \.(heic|HEIC)$ ]]; then
      _convert "$1"
    else
      echo "エラー: HEICファイルではありません: $1"
      return 1
    fi
  fi

  # 変換されたファイルがあれば削除するか確認
  if [[ ${#converted_files[@]} -gt 0 ]]; then
    echo ""
    echo "===== 変換完了: ${#converted_files[@]}ファイル ====="
    for f in "${converted_files[@]}"; do
      echo "$f"
    done
    echo ""
    echo -n "元のHEICファイルを削除しますか？ [y/N]: "
    read answer
    if [[ "$answer" =~ ^[Yy]$ ]]; then
      for f in "${converted_files[@]}"; do
        rm -f "$f"
        echo "削除: $f"
      done
      echo "元のHEICファイルを削除しました"
    else
      echo "元のHEICファイルは保持されました"
    fi
  fi
}

# for pyenv
export PYENV_ROOT=$HOME/.pyenv
export PATH=$PYENV_ROOT/bin:$PATH
eval "$(pyenv init --path)"
# pyenvを使った環境用
function pe { pyenv exec "$@"; }

# start HTTP server
alias http='python3 -m http.server'

# for rbenv and phpenv
eval "$(rbenv init -)"
eval "$(phpenv init -)"

# WP-CLI Tab completions
# http://wp-cli.org/
if [ -f $HOME/bin/wp-cli/wp-completion.bash ]; then
  autoload bashcompinit
  bashcompinit
  source $HOME/bin/wp-cli/wp-completion.bash
fi
#export MANPATH="/usr/local/man:$MANPATH"

# You may need to manually set your language environment
# export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR='vim'
# else
#   export EDITOR='mvim'
# fi

# Compilation flags
# export ARCHFLAGS="-arch x86_64"

# ssh
# export SSH_KEY_PATH="~/.ssh/dsa_id"
test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"

# heroku autocomplete setup
HEROKU_AC_ZSH_SETUP_PATH=$HOME/Library/Caches/heroku/autocomplete/zsh_setup && test -f $HEROKU_AC_ZSH_SETUP_PATH && source $HEROKU_AC_ZSH_SETUP_PATH;

# added by travis gem
[ -f $HOME/.travis/travis.sh ] && source $HOME/.travis/travis.sh


# ------------------------------------------------------------------
# Git Worktree Manager (Integrated Version)
# ------------------------------------------------------------------
# 実行には fzf (brew install fzf) が必要です。
#
# 使い方: gw
# 説明: メニューから 参照・追加・新規作成・削除 を選択して実行します。
#
# ※ Geminiで作成 https://gemini.google.com/app/7c2b14b4ba16931f?hl=ja
# ------------------------------------------------------------------
function gw() {
  # メニュー項目の定義
  local ACTIONS=(
    "1. Switch : ワークツリーを切り替える"
    "2. New    : 新規ブランチを作成して追加"
    "3. Add    : リモートブランチから作成"
    "4. Remove : ワークツリーを削除する"
  )

  # メニューを fzf で表示
  local action=$(printf "%s\n" "${ACTIONS[@]}" | fzf --height 15% --reverse --header "Git Worktree Menu")
  [ -z "$action" ] && return

  # Gitのメインリポジトリの絶対パスを取得（判定用）
  # git rev-parse --git-common-dir はワークツリー内でもメインの .git パスを返します
  local main_path=$(git rev-parse --path-format=absolute --git-common-dir | sed 's/\/\.git$//')

  case "$action" in
    "1. Switch"*)
      local selected=$(git worktree list | fzf --height 40% --reverse --header "移動先を選択" | awk '{print $1}')
      [ -n "$selected" ] && cd "$selected"
      ;;

    "2. New"*)
      local branch_name="feature/"
      # プロンプト一体型で入力
      vared -p "新規ブランチ名を入力: " branch_name
      [ -z "$branch_name" ] && return
      # ディレクトリ名用に / を - に置換
      local dir_name=$(echo $branch_name | sed 's/\//-/g')
      local target_dir="../$(basename $(pwd)).$dir_name"
      git worktree add -b "$branch_name" "$target_dir" && cd "$target_dir"
      ;;

    "3. Add"*)
      local branch=$(git branch -r | fzf --height 40% --reverse --header "対象ブランチを選択")
      [ -z "$branch" ] && return
      local clean_branch=$(echo $branch | sed 's/origin\///' | tr -d ' ')
      # ディレクトリ名用に / を - に置換
      local dir_name=$(echo $clean_branch | sed 's/\//-/g')
      local target_dir="../$(basename $(pwd)).$dir_name"
      git worktree add "$target_dir" "$clean_branch" && cd "$target_dir"
      ;;

    "4. Remove"*)
      # 削除対象を選択
      local selected_line=$(git worktree list | fzf --height 40% --reverse --header "削除するワークツリーを選択")
      [ -z "$selected_line" ] && return
      local selected_path=$(echo "$selected_line" | awk '{print $1}')

      # 判定ロジック：選択したパスがメインリポジトリのパスと一致するか
      if [ "$selected_path" = "$main_path" ]; then
        echo "エラー: メインリポジトリ ($main_path) は削除できません。"
        return
      fi

      echo -n "本当に削除しますか？ (y/n): "
      read opt
      if [ "$opt" = "y" ]; then
        # もし削除対象の中に今いるなら、削除前にメインへ避難する
        if [ "$(pwd)" = "$selected_path" ]; then
            echo "削除対象の中にいるため、メインリポジトリへ移動します。"
            cd "$main_path"
        fi
        git worktree remove "$selected_path"
        echo "削除完了しました。"
      fi
      ;;
  esac
}
# bun completions
[ -s "/Users/terada/.bun/_bun" ] && source "/Users/terada/.bun/_bun"

# bun
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"

export PATH="$HOME/.local/bin:$PATH"

alias claude-mem='/Users/terada/.bun/bin/bun "/Users/terada/.claude/plugins/marketplaces/thedotmack/plugin/scripts/worker-service.cjs"'
